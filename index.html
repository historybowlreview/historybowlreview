<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>History Bowl Study Program</title>
  <link rel="icon" href="290-2900079_dark-green-heart-shape.png" type="image/png">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>History Bowl Study Program üíöü§ç</title>
<style>
    /* --------- Visual styles (kept from your original, adjusted slightly) ---------- */
    *{box-sizing:border-box;margin:0;padding:0}
    body{
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg,#667eea 0%,#764ba2 100%);
        min-height:100vh;color:#222;padding:24px;
    }
    .container{max-width:1100px;margin:0 auto;background:transparent}
    #setPickerModal {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      z-index: 9999;
      background: rgba(0,0,0,0.35);
      display: none;
    }
    #setPickerModal > div {
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      background: white;
      padding: 28px;
      border-radius: 16px;
      box-shadow: 0 10px 40px rgba(60,40,80,0.25);
      min-width: 320px;
      max-width: 96vw;
    }
    .header{text-align:center;color:#fff;margin-bottom:20px}
    .header h1{font-size:2.2rem;text-shadow:2px 2px 4px rgba(0,0,0,0.25)}
    .menu{display:grid;grid-template-columns:repeat(auto-fit,minmax(240px,1fr));gap:16px;margin-bottom:16px}
    .card{background:rgba(255,255,255,0.95);padding:18px;border-radius:12px;box-shadow:0 8px 24px rgba(0,0,0,0.12);cursor:pointer}
    .card h3{color:#5a67d8;margin-bottom:8px}
    .btn{background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);color:white;border:none;padding:10px 14px;border-radius:8px;cursor:pointer;font-weight:600}
    .btn.secondary{background:#6c757d;margin-left:8px}
    .game-area{display:none;margin-bottom:18px}
    .scoreboard{display:flex;gap:12px;align-items:center;background:#f8f9fa;padding:12px;border-radius:10px;margin-bottom:12px}
    .team-score{flex:1;text-align:center;padding:8px;background:white;border-radius:8px;box-shadow:0 2px 8px rgba(0,0,0,0.06)}
    .team-name{font-weight:700;color:#5a67d8}
    .score{font-size:1.6rem;font-weight:800}
    .question-area{background:#f8f9fa;padding:16px;border-left:6px solid #5a67d8;border-radius:8px;min-height:110px}
    .question-text{font-size:1.05rem;color:#2d3748;min-height:62px}
    .controls{display:flex;gap:8px;align-items:center;margin-top:12px;flex-wrap:wrap}
    .buzzer-btn{background:#e53e3e;color:white;padding:12px 22px;border-radius:999px;border:none;font-size:16px;font-weight:700;cursor:pointer}
    .buzzer-btn:disabled{background:#a0aec0;cursor:not-allowed}
    .answer-input{padding:10px;border-radius:8px;border:2px solid #e2e8f0;font-size:15px;width:100%;max-width:520px}
    .feedback{margin-top:10px;padding:12px;border-radius:8px;font-weight:700;display:none}
    .feedback.correct{background:#c6f6d5;color:#22543d;border:1px solid #9ae6b4}
    .feedback.incorrect{background:#fed7d7;color:#742a2a;border:1px solid #fc8181}
    .hidden{display:none}
    .categories{display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:12px;margin-top:12px}
    .category-btn{padding:12px;border-radius:8px;background:white;border:1px solid #e2e8f0;cursor:pointer;text-align:center}
    .category-btn.selected{background:#5a67d8;color:white;border-color:#5a67d8}
    .admin-panel{display:none;background:rgba(255,255,255,0.95);padding:16px;border-radius:12px;margin-top:12px}
    .question-list{background:white;padding:12px;border-radius:8px;max-height:260px;overflow:auto;margin-top:8px}
    .controls-row{display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin-top:10px}
    .leaderboard{background:#fff;padding:12px;border-radius:8px;margin-top:12px;max-height:260px;overflow:auto}
    .small{font-size:0.9rem;color:#444}
    .muted{color:#666;font-size:0.9rem}
    .tab-btn {
        background: #f3f4f6;
        color: #5a67d8;
        border: none;
        border-radius: 6px 6px 0 0;
        padding: 8px 16px;
        margin-right: 4px;
        cursor: pointer;
        font-weight: 600;
    }
    .tab-btn.active {
        background: #5a67d8;
        color: white;
    }
    .categories.hidden {
      display: none !important;
    }
    .error{color:#e53e3e;background:#fed7d7;padding:8px;border-radius:8px;margin:8px 0}
    footer{margin-top:18px;color:#fff;text-align:center;font-size:0.9rem}
    @media (max-width:700px){.scoreboard{flex-direction:column}}
</style>
</head>
<body>
  <div class="container">
    <!-- Header -->
    <div class="header">
      <h1>üíöü§ç History Bowl Study Program</h1>
      <p class="small">Specific quarter practice + Full-game simulation with response time tracking and leaderboards ü§çüíö</p>
    </div>
    <div id="questionsStatus" class="small muted"></div>
    <div id="questionsDisplay"></div>

    <!-- Set Picker Modal -->
    <div id="setPickerModal" style="display:none;">
      <div style="background:white;...">
        <h3>Select Practice Sets</h3>
        <!-- Tabs go above -->
        <div id="setPickerTabs"></div>
        <!-- Set list below tabs -->
        <div id="setPickerList" style="max-height:300px;overflow-y:auto;margin-bottom:18px;"></div>
        <!-- Buttons below set list -->
        <button id="selectAllYearBtn">Select All This Year</button>
        <button id="deselectAllYearBtn">Deselect All This Year</button>
        <button onclick="selectAllSets()">Select All</button>
        <button onclick="deselectAllSets()">Deselect All</button>
        <button onclick="confirmSetPicker()">Confirm</button>
        <button onclick="cancelSetPicker()" style="margin-left:12px;">Cancel</button>
      </div>
    </div>

    <!-- Main Menu -->
    <div id="mainMenu" class="menu">
      <div class="card" onclick="openPracticeMode()">
        <h3>üéØ Practice Mode</h3>
        <p class="muted">Pick a quarter to practice specific formats and question types.</p>
        <div style="margin-top:10px"><button class="btn">Start Practice</button></div>
      </div>
      <div class="card" onclick="startFullGameFromMenu()">
        <h3>üèÜ Full Game Simulation</h3>
        <p class="muted">Play a full match (Q1‚ÜíQ4) with official scoring.</p>
        <div style="margin-top:10px"><button class="btn">Start Full Game</button></div>
      </div>
      <div class="card" onclick="showLeaderboardPanel()">
        <h3>üèÖ Global Leaderboard</h3>
        <p class="muted">Shows all full game attempts ordered by score. Enter your name to save it with your score.</p>
        <div style="margin-top:10px"><button class="btn">View Leaderboard</button></div>
      </div>
      <!-- Player Name Input -->
      <div id="playerNameContainer" style="margin-bottom: 10px;">
        <input type="text" id="playerNameInput" placeholder="Enter your name" maxlength="20" style="padding: 5px; width: 200px;">
      </div>
    </div>

    <!-- Game Area -->
    <div id="gameArea" class="game-area">
      <div class="scoreboard">
        <div class="team-score">
          <div class="team-name">Score</div>
          <div class="score" id="rawScore">0</div>
          <div class="small muted">Total points</div>
        </div>
        <div style="text-align:center">
          <div class="small">Quarter</div>
          <div id="q3PrefixBox" class="hidden" style="font-weight:600;font-size:1.08em;margin-bottom:6px;"></div>
          <div id="quarterDisplay" style="font-weight:700">1</div>
          <div id="questionCounter" class="small muted">Q 0 / 0</div>
        </div>
        <div class="team-score">
          <div class="team-name">Avg Buzz-in</div>
          <div class="score" id="avgResponseTime">--</div>
          <div class="small muted">Seconds to buzz</div>
        </div>
      </div>
      <div style="text-align:center">
        <div class="small">Timer</div>
        <div id="timerDisplay" style="font-weight:700">--</div>
      </div>
      <div class="question-area">
        <div id="questionText" class="question-text">Load questions first, then click "Next Question" to begin.</div>
      </div>
      <div class="controls">
        <button id="buzzerBtn" class="buzzer-btn" onclick="buzz()" disabled>üîî BUZZ</button>
        <button class="btn secondary" id="showAnswerBtn" onclick="showAnswer()">Show Answer</button>
        <div style="margin-left:auto;display:flex;gap:8px;align-items:center">
          <div class="small muted">Mode:</div>
          <div id="modeDisplay" style="font-weight:700">Practice</div>
        </div>
      </div>
      <div class="controls-row">
        <input id="answerInput" class="answer-input" placeholder="Type answer and press Enter or Submit..." disabled>
        <button class="btn" onclick="submitAnswer()">Submit</button>
        <div id="currentResponseTime" class="small muted">Response time: --</div>
      </div>
      <div id="feedback" class="feedback"></div>
      <!-- Q3 category selection area -->
      <div id="categorySelection" class="categories hidden"></div>
      <!-- Controls to go back or reset -->
      <div class="controls-row" style="margin-top:12px">
        <button class="btn secondary" onclick="backToMenu()">Back to Menu</button>
        <button class="btn secondary" id="pauseBtn" onclick="togglePause()">Pause</button>
        <button class="btn" onclick="resetPracticeGame()">Reset Game</button>
      </div>
    </div>

    <!-- Leaderboard Panel -->
    <div id="leaderboardPanel" class="admin-panel hidden">
      <h3>Global Leaderboard (all attempts)</h3>
      <div style="display:flex;gap:8px;margin-bottom:8px;align-items:center">
        <button class="btn secondary" onclick="backToMenu()">Back to Menu</button>
      </div>
      <div class="leaderboard" id="leaderboardList"></div>
    </div>

<script>
/* ================================================================
   Game state & helpers
   ================================================================ */
let QUESTIONS = {
    q1: [],
    q2: [],
    q3: [],
    q4: []
};

// Fetch questions from server
async function loadQuestionsFromServer() { 
    try {
        const response = await fetch('questions.json');
        if (!response.ok) throw new Error("Failed to load questions.json");
        const jsonData = await response.json();

        if (!jsonData.q1 || !jsonData.q2 || !jsonData.q3 || !jsonData.q4) {
            throw new Error("questions.json must contain q1, q2, q3, q4");
        }

        QUESTIONS = jsonData;
        gameState.questionsLoaded = true;

        const q3Count = jsonData.q3.reduce((sum, cat) => sum + cat.questions.length, 0);
        const q4Count = jsonData.q4.reduce((sum, group) => sum + group.parts.length, 0);

        updateQuestionsStatus(
            `Successfully loaded: Q1(${jsonData.q1.length}) Q2(${jsonData.q2.length}) Q3(${q3Count}) Q4(${q4Count})`,
            true
        );

        renderQuestionsDisplay();

    } catch (err) {
        updateQuestionsStatus("Error: " + err.message, false);
        gameState.questionsLoaded = false;
        console.error(err);
    }
}

let QUESTIONS_SETS = [];

async function loadAllQuestionSets(files) {
    QUESTIONS_SETS = [];
    for (const file of files) {
        const response = await fetch(file);
        const data = await response.json();
        QUESTIONS_SETS.push(data);
    }
    gameState.questionsLoaded = true; // <-- Add this line!
}

function selectAllSets() {
    const checkboxes = document.querySelectorAll('#setPickerList input[type=checkbox]');
    checkboxes.forEach(cb => cb.checked = true);
}

function deselectAllSets() {
    const checkboxes = document.querySelectorAll('#setPickerList input[type=checkbox]');
    checkboxes.forEach(cb => cb.checked = false);
}

function openSetPicker(availableFiles, callback) {
    window._setPickerCallback = callback;
    window._setPickerFiles = availableFiles;
    const tabsContainer = $('setPickerTabs');
    const list = $('setPickerList');
    tabsContainer.innerHTML = '';
    list.innerHTML = '';

    // Render tabs for each year
    availableFiles.forEach((group, idx) => {
        const tab = document.createElement('button');
        tab.textContent = group.year;
        tab.className = 'tab-btn';
        tab.onclick = () => renderSetList(idx);
        tabsContainer.appendChild(tab);
    });

    // Initially show first year
    renderSetList(0);

    function renderSetList(yearIdx) {
        list.innerHTML = '';
        const sets = availableFiles[yearIdx].sets;
        sets.forEach((set, idx) => {
            const div = document.createElement('div');
            div.innerHTML = `<label><input type="checkbox" value="${yearIdx}-${idx}"> ${set.name}</label>`;
            list.appendChild(div);
        });

        // Add select/deselect all for this year
        $('selectAllYearBtn').onclick = () => {
            list.querySelectorAll('input[type=checkbox]').forEach(cb => cb.checked = true);
        };
        $('deselectAllYearBtn').onclick = () => {
            list.querySelectorAll('input[type=checkbox]').forEach(cb => cb.checked = false);
        };
    }
    $('setPickerModal').style.display = 'block';

    // ...Modal open/close logic as before
}

function confirmSetPicker() {
    const modal = $('setPickerModal');
    const checkboxes = $('setPickerList').querySelectorAll('input[type=checkbox]');
    const selected = [];
    for (const cb of checkboxes) {
        if (cb.checked) {
            // cb.value is "yearIdx-setIdx"
            const [yearIdx, setIdx] = cb.value.split('-').map(Number);
            const file = window._setPickerFiles[yearIdx].sets[setIdx].file;
            selected.push(file);
        }
    }
    if (selected.length === 0) {
        alert('Please select at least one set.');
        return;
    }
    modal.style.display = 'none';
    window._setPickerCallback(selected);
}

function cancelSetPicker() {
    $('setPickerModal').style.display = 'none';
    window._setPickerCallback(null);
    backToMenu();
}

// Utility to pick random item
function getRandomItem(array) {
    return array[Math.floor(Math.random() * array.length)];
}

// Functions to get questions on-demand ‚Äî only pick what‚Äôs needed, don't pre-load
function getRandomQ1() {
    if (!QUESTIONS.q1.length) return null;
    return getRandomItem(QUESTIONS.q1);
}

function getRandomQ2() {
    if (!QUESTIONS.q2.length) return null;
    return getRandomItem(QUESTIONS.q2);
}

function getRandomQ3() {
    if (!QUESTIONS.q3.length) return [];
    const shuffledCategories = [...QUESTIONS.q3].sort(() => Math.random() - 0.5);
    return shuffledCategories.slice(0, 3); // 3 random categories with 6 questions each
}

function getRandomQ4Part() {
    if (!QUESTIONS.q4.length) return null;
    const group = getRandomItem(QUESTIONS.q4);
    return getRandomItem(group.parts);
}

function updateQ3PrefixBox(show) {
    const box = $('q3PrefixBox');
    if (show) {
        box.textContent = "Millard Fillmore is or was...";
        box.classList.remove('hidden');
    } else {
        box.classList.add('hidden');
        box.textContent = "";
    }
}

// Example usage:
// const q1Question = getRandomQuestion('q1');
// const q2Question = getRandomQuestion('q2');
// const q3Categories = getRandomQ3Categories();
// const q4Question = getRandomQ4Question();

let gameState = {
    mode: null,
    currentQuarter: 1,
    q3CategoryQuestions: [],
    q3Timer: null,
    q3TimeLeft: 60,
    q3CurrentQuestionIdx: 0,
    q3CategoryActive: false,
    currentQuestionIndex: -1,
    rawScore: 0,
    responseTimes: [], // Array to track response times
    readingInterval: null,
    postReadTimer: null,
    answerTimer: null,
    readingCharIndex: 0,
    q4CurrentPart: 0,
    currentQuestionText: "",
    isPaused: false,
    savedIntervals: {},
    currentAnswer: "",
    currentBonus: null,
    buzzed: false,
    buzzInTimes: [],
    multiplier: 1,
    pausedPostReadTime: null,
    pausedAnswerTime: null,
    wasReading: false,
    q3selectedCategory: null,
    q3categoryProgress: 0,
    q3categoryCorrectCount: 0,
    q3Swept: false,
    lastActionTimestamp: null,
    questionStartTime: null, // When question reading began
    buzzTime: null, // When user buzzed
    questionsLoaded: false
};

const $ = id => document.getElementById(id);

/* ------------------ Question Loading ------------------ */

function updateQuestionsStatus(message, success) {
    const statusEl = $('questionsStatus');
    statusEl.textContent = message;
    statusEl.className = success ? 'small muted' : 'small error';
}

/* ------------------ UI helpers ------------------ */
function updateScoreDisplays(){
    $('rawScore').textContent = gameState.rawScore;

    // Calculate and display average response time
    const avgBuzz = calculateAverageBuzzInTime();
    $('avgResponseTime').textContent = avgBuzz !== null ? avgBuzz.toFixed(1) + 's' : '--';

    $('quarterDisplay').textContent = gameState.currentQuarter;
}

function calculateAverageResponseTime() {
    if (gameState.responseTimes.length === 0) return null;
    const sum = gameState.responseTimes.reduce((a, b) => a + b, 0);
    return sum / gameState.responseTimes.length;
}

function looseMatch(given, answer) {
  const articles = ["the", "a", "an", "of"];
  function tokenize(s) {
    return s
      .toLowerCase()
      .replace(/[^a-z0-9' ]+/g, '')
      .split(/\s+/)
      .filter(w => w && !articles.includes(w));
  }
  const givenWords = tokenize(given);
  const answerWords = tokenize(Array.isArray(answer) ? answer[0] : answer);

  if (!givenWords.length || !answerWords.length) return false;
  if (givenWords.length !== answerWords.length) return false;
  return givenWords.every(w => answerWords.includes(w));
}

function setFeedback(text, ok=true){
    const f = $('feedback');
    f.textContent = text;
    f.classList.remove('correct','incorrect');
    f.classList.add(ok ? 'correct' : 'incorrect');
    f.style.display = 'block';
    setTimeout(()=>{ f.style.display = 'none'; }, 10000);
}

function clearFeedback(){
    const f = $('feedback');
    f.style.display = 'none';
}

/* ------------------ Navigation / menu ------------------ */
function backToMenu(){
    clearAllTimers();
    updatePauseButtonVisibility();
    $('gameArea').style.display = 'none';
    $('leaderboardPanel').style.display = 'none';
    $('mainMenu').style.display = 'grid';
    $('categorySelection').classList.add('hidden');
    gameState.mode = 'practice';
    $('modeDisplay').textContent = 'Practice';
}

async function openPracticeMode() {
    gameState.mode = 'practice';
    $('modeDisplay').textContent = 'Practice';
    $('mainMenu').style.display = 'none';
    updatePauseButtonVisibility();
    $('gameArea').style.display = 'block';

    // Prompt for set picker FIRST
    const selectedFiles = await promptPracticeSet();
    if (!selectedFiles) { backToMenu(); return; }
    await loadAllQuestionSets(selectedFiles);
    if (!QUESTIONS_SETS.length) {
        alert("Failed to load selected question sets.");
        backToMenu();
        return;
    }
    assignPracticeQuestionsFromSets(QUESTIONS_SETS);

    // THEN prompt for quarter
    if (promptPracticeQuarter()) {
        resetGame();
        nextQuestion();
    } else {
        backToMenu();
    }
}

function assignPracticeQuestionsFromSets(sets) {
    gameState.activeQ1 = sets.flatMap(set => set.q1 || []);
    gameState.activeQ2 = sets.flatMap(set => set.q2 || []);
    gameState.activeQ3 = sets.flatMap(set => set.q3 || []);
    gameState.activeQ4 = sets.flatMap(set => set.q4 || []);
}

function promptPracticeQuarter() {
    const choice = prompt("Enter practice quarter (1,2,3,4) or 'q' to cancel:", "1");
    if (!choice || choice.toLowerCase() === 'q') {
        backToMenu();
        return false;
    }
    const q = parseInt(choice);
    if (![1,2,3,4].includes(q)) {
        alert("Invalid quarter");
        return promptPracticeQuarter();
    }
    gameState.currentQuarter = q;
    gameState.practiceQuarterSelected = true;
    gameState.currentQuestionIndex = -1;
    gameState.q3selectedCategory = null;
    gameState.q3categoryProgress = 0;
    return true;
}

function startFullGameFromMenu() {
    if (!gameState.questionsLoaded) {
        alert("Questions failed to load.");
        return;
    }
    gameState.mode = 'full'; // Set mode BEFORE resetGame
    resetGame();
    updatePauseButtonVisibility();
    $('modeDisplay').textContent = 'Full Game';
    $('mainMenu').style.display = 'none';
    $('gameArea').style.display = 'block';
    startGame();
}

function startPostReadTimer() {
    gameState.postReadTimeLeft = 5;
    $('timerDisplay').textContent = `Buzz time: ${gameState.postReadTimeLeft}`;
    gameState.postReadTimer = setInterval(() => {
        gameState.postReadTimeLeft--;
        $('timerDisplay').textContent = `Buzz time: ${gameState.postReadTimeLeft}`;
        if (gameState.postReadTimeLeft <= 0) {
            clearInterval(gameState.postReadTimer);
            gameState.postReadTimer = null;
            $('buzzerBtn').disabled = true;
            $('timerDisplay').textContent = "Time's up";
            setFeedback(`Time expired! No points awarded. The correct answer was: ${formatAnswer(gameState.currentAnswer)}`, false);
            startFeedbackCountdown(10);
            $('questionText').textContent = gameState.currentQuestionText;
            setTimeout(() => {
                nextQuestion();
            }, 10000);
        }
    }, 1000);
}

function startAnswerTimer() {
    gameState.answerTimeLeft = 10;
    $('timerDisplay').textContent = `Answer time: ${gameState.answerTimeLeft}`;
    gameState.answerTimer = setInterval(() => {
        gameState.answerTimeLeft--;
        $('timerDisplay').textContent = `Answer time: ${gameState.answerTimeLeft}`;
        if (gameState.answerTimeLeft <= 0) {
            clearInterval(gameState.answerTimer);
            gameState.answerTimer = null;
            $('answerInput').disabled = true;
            $('timerDisplay').textContent = "Time expired";
            setFeedback(`Correct answer: ${formatAnswer(gameState.currentAnswer)}`, false);
            startFeedbackCountdown(10);
            $('questionText').textContent = gameState.currentQuestionText;
            setTimeout(() => {
                nextQuestion();
            }, 10000);
        }
    }, 1000);
}

function showLeaderboardPanel(){
    clearAllTimers();
    $('mainMenu').style.display = 'none';
    $('gameArea').style.display = 'none';
    $('leaderboardPanel').style.display = 'block';
    renderGlobalLeaderboard();
}

/* ------------------ Timer/Reading helpers ------------------ */
function clearAllTimers(){
    if (gameState.readingInterval){ 
        clearInterval(gameState.readingInterval); 
        gameState.readingInterval = null; 
    }
    if (gameState.postReadTimer){ 
        clearInterval(gameState.postReadTimer); 
        gameState.postReadTimer = null; 
    }
    if (gameState.answerTimer){ 
        clearInterval(gameState.answerTimer); 
        gameState.answerTimer = null; 
    }
    if (gameState.q3Timer) {
        clearInterval(gameState.q3Timer);
        gameState.q3Timer = null;
    }
}

function startGame(){
    resetGame();
    gameState.mode = 'full';
    $('modeDisplay').textContent = 'Full Game';
    gameState.currentQuarter = 1;
    gameState.currentQuestionIndex = -1;
    updateScoreDisplays();
    nextQuestion();
}

// --- Feedback Timer Pause Logic ---
function togglePause() {
    if (!gameState.isPaused) {
        // PAUSE
        gameState.wasReading = !!gameState.readingInterval;
        if (gameState.readingInterval) clearInterval(gameState.readingInterval);
        if (gameState.postReadTimer) {
            const val = $('timerDisplay').textContent.match(/Buzz time: ([0-9]+)/);
            gameState.pausedPostReadTime = val ? parseInt(val[1]) : null;
            clearInterval(gameState.postReadTimer);
        }
        if (gameState.answerTimer) {
            const val = $('timerDisplay').textContent.match(/Answer time: ([0-9]+)/);
            gameState.pausedAnswerTime = val ? parseInt(val[1]) : null;
            clearInterval(gameState.answerTimer);
        }
        if (gameState.q3Timer) {
            gameState.pausedQ3Time = gameState.q3TimeLeft;
            clearInterval(gameState.q3Timer);
        }
        if (
            gameState.feedbackTimer &&
            typeof gameState.feedbackTimeLeft === 'number' &&
            !isNaN(gameState.feedbackTimeLeft) &&
            gameState.feedbackTimeLeft > 0
        ) {
            clearInterval(gameState.feedbackTimer);
            gameState.pausedFeedbackTime = gameState.feedbackTimeLeft;
        }
        gameState.isPaused = true;
        $('pauseBtn').textContent = "Resume";
        setFeedback("Paused. Press Resume to continue.", true);
        $('buzzerBtn').disabled = true;
        $('showAnswerBtn').disabled = true;

        // Only re-enable answer input if buzzed or it's Q3 category mode
        if (gameState.buzzed || (gameState.currentQuarter === 3 && gameState.q3CategoryActive)) {
            $('answerInput').disabled = false;
        } else {
            $('answerInput').disabled = true;
        }
    } else {
        // RESUME
        gameState.isPaused = false;
        $('pauseBtn').textContent = "Pause";
        clearFeedback();
        if (gameState.wasReading) resumeReading();
        if (gameState.currentQuarter === 3 && gameState.q3CategoryActive && typeof gameState.pausedQ3Time === 'number') {
            gameState.q3TimeLeft = gameState.pausedQ3Time;
            startQ3CategoryTimer();
        }
    
        // Resume timer if paused after Show Answer
        if (
            typeof gameState.pausedFeedbackTime === 'number' &&
            !isNaN(gameState.pausedFeedbackTime) &&
            gameState.pausedFeedbackTime > 0
        ) {
            resumeFeedbackCountdown(gameState.pausedFeedbackTime);
            gameState.pausedFeedbackTime = null;
        }

        gameState.pausedPostReadTime = null;
        gameState.pausedAnswerTime = null;
        gameState.pausedQ3Time = null;
        gameState.pausedFeedbackTime = null;
        gameState.wasReading = false;

        // --- Add this logic here ---
        if (
            gameState.buzzed ||
            (gameState.currentQuarter === 3 && gameState.q3CategoryActive)
        ) {
            $('buzzerBtn').disabled = true;
        } else {
            $('buzzerBtn').disabled = false;
        }

        $('showAnswerBtn').disabled = gameState.isShowingAnswer ? true : false;

        if (gameState.buzzed || (gameState.currentQuarter === 3 && gameState.q3CategoryActive)) {
            $('answerInput').disabled = false;
        } else {
            $('answerInput').disabled = true;
        }
    }
}

// Add this function:
function resumeFeedbackCountdown(timeLeft) {
    if (
        typeof timeLeft !== 'number' ||
        isNaN(timeLeft) ||
        timeLeft <= 0
    ) {
        nextQuestion();
        return;
    }
    if (gameState.feedbackTimer) clearInterval(gameState.feedbackTimer);
    gameState.feedbackTimeLeft = timeLeft; // <--- Set here
    $('timerDisplay').textContent = `Next question in: ${timeLeft}`;
    gameState.feedbackTimer = setInterval(() => {
        timeLeft--;
        gameState.feedbackTimeLeft = timeLeft; // <--- Keep updating
        $('timerDisplay').textContent = `Next question in: ${timeLeft}`;
        if (timeLeft <= 0) {
            clearInterval(gameState.feedbackTimer);
            gameState.feedbackTimer = null;
            $('timerDisplay').textContent = '--';
            nextQuestion();
        }
    }, 1000);
}

function resumeReading() {
    const questionText = gameState.currentQuestionText;
    const idx = gameState.readingCharIndex;
    $('questionText').textContent = questionText.slice(0, idx);
    gameState.readingInterval = setInterval(() => {
        if (gameState.readingCharIndex < questionText.length && !gameState.buzzed) {
            $('questionText').textContent += questionText[gameState.readingCharIndex];
            gameState.readingCharIndex++;
        } else {
            clearInterval(gameState.readingInterval);
            gameState.readingInterval = null;
            // Start post-read timer as usual
            startPostReadTimer();
        }
    }, 30);
}

function resumePostReadTimer() {
    $('timerDisplay').textContent = `Buzz time: ${gameState.postReadTimeLeft}`;
    gameState.postReadTimer = setInterval(() => {
        gameState.postReadTimeLeft--;
        $('timerDisplay').textContent = `Buzz time: ${gameState.postReadTimeLeft}`;
        if (gameState.postReadTimeLeft <= 0) {
            clearInterval(gameState.postReadTimer);
            gameState.postReadTimer = null;
            $('buzzerBtn').disabled = true;
            $('timerDisplay').textContent = "Time's up";
            setFeedback(`Time expired! No points awarded. The correct answer was: ${formatAnswer(gameState.currentAnswer)}`, false);
            startFeedbackCountdown(10);
            $('questionText').textContent = gameState.currentQuestionText;
            setTimeout(() => {
                nextQuestion();
            }, 10000);
        }
    }, 1000);
}

function resumeAnswerTimer() {
    $('timerDisplay').textContent = `Answer time: ${gameState.answerTimeLeft}`;
    gameState.answerTimer = setInterval(() => {
        gameState.answerTimeLeft--;
        $('timerDisplay').textContent = `Answer time: ${gameState.answerTimeLeft}`;
        if (gameState.answerTimeLeft <= 0) {
            clearInterval(gameState.answerTimer);
            gameState.answerTimer = null;
            $('answerInput').disabled = true;
            $('timerDisplay').textContent = "Time expired";
            setFeedback(`Correct answer: ${formatAnswer(gameState.currentAnswer)}`, false);
            startFeedbackCountdown(10);
            $('questionText').textContent = gameState.currentQuestionText;
            setTimeout(() => {
                nextQuestion();
            }, 10000);
        }
    }, 1000);
}

/* ------------------ Reset ------------------ */
function updatePauseButtonVisibility() {
    $('pauseBtn').style.display = (gameState.mode === 'practice') ? 'inline-block' : 'none';
}

function resetGame() {
    clearAllTimers();
    gameState = {
        ...gameState,
        currentQuarter: gameState.currentQuarter,
        currentQuestionIndex: -1,
        rawScore: 0,
        responseTimes: [],
        readingInterval: null,
        postReadTimer: null,
        answerTimer: null,
        pausedPostReadTime: null,
        bonusTimer: null,
        bonusTimeLeft: null,
        pausedAnswerTime: null,
        wasReading: false,
        readingCharIndex: 0,
        currentQuestionText: "",
        currentAnswer: "",
        currentBonus: null,
        buzzed: false,
        buzzInTimes: [],
        isPaused: false,
        savedIntervals: {},
        multiplier: 1,
        q3selectedCategory: null,
        q3categoryProgress: 0,
        q3categoryCorrectCount: 0,
        q3Swept: false,
        lastActionTimestamp: null,
        questionStartTime: null,
        buzzTime: null,
        practiceQuarterSelected: false
    };

    // Pick question set depending on mode
    if (gameState.mode === 'full') {
        // Full game: use the master QUESTIONS object
        gameState.activeQ1 = shuffle([...QUESTIONS.q1]).slice(0, 10);
        gameState.activeQ2 = shuffle([...QUESTIONS.q2]).slice(0, 8);
        gameState.activeQ4 = shuffle([...QUESTIONS.q4]).slice(0, 8);
        gameState.activeQ3 = [getRandomItem([...QUESTIONS.q3])];
    } else {
        // Practice mode: use ONLY previously assigned question sets
        // Do NOT reassign from master QUESTIONS!
        // gameState.activeQ1, activeQ2, activeQ3, activeQ4 are already set by assignPracticeQuestionsFromSets()
        // Just shuffle them again if you want random order:
        if (Array.isArray(gameState.activeQ1)) gameState.activeQ1 = shuffle([...gameState.activeQ1]);
        if (Array.isArray(gameState.activeQ2)) gameState.activeQ2 = shuffle([...gameState.activeQ2]);
        if (Array.isArray(gameState.activeQ3)) gameState.activeQ3 = shuffle([...gameState.activeQ3]);
        if (Array.isArray(gameState.activeQ4)) gameState.activeQ4 = shuffle([...gameState.activeQ4]);
    }

    $('questionText').textContent = gameState.questionsLoaded ?
        "Click 'Next Question' to start!" :
        "Questions failed to load";
    $('buzzerBtn').disabled = true;
    $('answerInput').disabled = true;
    $('categorySelection').classList.add('hidden');
    $('answerInput').value = '';
    $('currentResponseTime').textContent = 'Response time: --';
    $('questionCounter').textContent = 'Q 0 / 0';
    $('timerDisplay').textContent = '--';
    updateScoreDisplays();
    clearFeedback();
}


async function resetPracticeGame() {
    if (gameState.mode === 'full') {
        startFullGameFromMenu();
    } else {
        gameState.mode = 'practice';
        $('modeDisplay').textContent = 'Practice';
        $('mainMenu').style.display = 'none';
        $('gameArea').style.display = 'block';

        // Prompt for set picker FIRST
        const selectedFiles = await promptPracticeSet();
        if (!selectedFiles) { backToMenu(); return; }
        await loadAllQuestionSets(selectedFiles);
        if (!QUESTIONS_SETS.length) {
            alert("Failed to load selected question sets.");
            backToMenu();
            return;
        }
        assignPracticeQuestionsFromSets(QUESTIONS_SETS);

        // THEN prompt for quarter
        if (promptPracticeQuarter()) {
            resetGame();
            updatePauseButtonVisibility();
            nextQuestion();
        } else {
            backToMenu();
        }
    }
}

function shuffle(array){
    for (let i = array.length - 1; i > 0; i--){
        const j = Math.floor(Math.random() * (i+1));
        [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
}

/* ------------------ Question selection helpers ------------------ */
function getCurrentQuarterArray(){
    if (gameState.currentQuarter === 1) return gameState.activeQ1;
    if (gameState.currentQuarter === 2) return gameState.activeQ2;
    if (gameState.currentQuarter === 3) return gameState.activeQ3;
    if (gameState.currentQuarter === 4) return gameState.activeQ4;
    return [];
}

/* ------------------ Start Next Question ------------------ */
function nextQuestion() {
    if (!gameState.questionsLoaded) {
        alert("Questions failed to load.");
        return;
    }

    clearAllTimers();
    clearFeedback();
    $('showAnswerBtn').disabled = false;

    // Quarter 3: Category
    if (gameState.currentQuarter === 3) {
        if (gameState.q3selectedCategory === null) {
            showCategorySelection();
            return;
        }
        if (gameState.mode === 'full') {
            QUESTIONS.q3 = gameState.activeQ3;
        }

        const cat = QUESTIONS.q3[gameState.q3selectedCategory];
        if (!cat || !cat.questions || cat.questions.length === 0){
            $('questionText').textContent = "No questions in this category.";
            return;
        }

        if (gameState.q3categoryProgress >= cat.questions.length) {
            if (gameState.mode === 'full') {
                gameState.currentQuarter++;
                gameState.currentQuestionIndex = -1;
                gameState.q3selectedCategory = null;
                gameState.q3categoryProgress = 0;
                nextQuestion();
                return;
            } else {
                gameState.q3selectedCategory = null;
                showCategorySelection();
                return;
            }
        }

        showQ3CategoryQuestion();
        return;
    }

    // Quarters 1,2,4: increment index
    if (gameState.currentQuarter === 1) {
        gameState.currentQuestionIndex++;
        if (gameState.currentQuestionIndex >= gameState.activeQ1.length) {
            if (gameState.mode === 'full') {
                gameState.currentQuarter++;
                gameState.currentQuestionIndex = -1;
                nextQuestion();
                return;
            } else {
                alert(`No more questions in Quarter 1.`);
                gameState.currentQuestionIndex = gameState.activeQ1.length - 1;
                return;
            }
        }
    } else if (gameState.currentQuarter === 2) {
        if (!gameState.isAnsweringBonus) {
            gameState.currentQuestionIndex++;
        }
        if (gameState.currentQuestionIndex >= gameState.activeQ2.length) {
            if (gameState.mode === 'full') {
                gameState.currentQuarter++;
                gameState.currentQuestionIndex = -1;
                nextQuestion();
                return;
            } else {
                alert(`No more questions in Quarter 2.`);
                gameState.currentQuestionIndex = gameState.activeQ2.length - 1;
                return;
            }
        }
    } else if (gameState.currentQuarter === 4) {
        gameState.currentQuestionIndex++;
        if (gameState.currentQuestionIndex >= gameState.activeQ4.length) {
            if (gameState.mode === 'full') {
                finishGame();
                return;
            } else {
                alert(`No more questions in Quarter 4.`);
                gameState.currentQuestionIndex = gameState.activeQ4.length - 1;
                return;
            }
        }
    }

    // Prepare question UI
    $('buzzerBtn').disabled = false;
    $('answerInput').disabled = true;
    $('answerInput').value = '';
    $('questionText').textContent = 'Get ready...';
    $('questionCounter').textContent = computeQuestionCounterText();
    $('currentResponseTime').textContent = 'Response time: --';
    $('categorySelection').classList.add('hidden');

    // Record question start time
    gameState.questionStartTime = Date.now();

    // Start reading question
    setTimeout(() => startReading(), 800);
}

/* ------------------ Category selection for Q3 ------------------ */
function showCategorySelection(){
    const container = $('categorySelection');
    container.innerHTML = `<h4 style="width:100%">Select a Category</h4>`;
    container.classList.remove('hidden');
    
    // Select 3 random categories
    let categories = QUESTIONS.q3;
    let pairs = categories.map((cat, idx) => ({cat, idx}));
    let selected = pairs.sort(() => Math.random() - 0.5).slice(0, 3);

    selected.forEach(({cat, idx}) => {
        const btn = document.createElement('div');
        btn.className = 'category-btn';
        btn.textContent = `${cat.category} (${(cat.questions||[]).length} q)`;
        btn.onclick = () => {
            console.log("Category selected: ", idx);
            container.classList.add('hidden');
            selectCategory(idx);
        };
        container.appendChild(btn);
    });
}

function selectCategory(idx) {
    gameState.q3selectedCategory = idx;
    gameState.q3categoryProgress = 0;
    gameState.q3categoryCorrectCount = 0;

    gameState.q3CategoryQuestions = QUESTIONS.q3[idx].questions
        .map(q => ({ ...q, userAnswer: "", isCorrect: false }));
    // Remove the sort/shuffle line!

    gameState.q3CurrentQuestionIdx = 0;
    gameState.q3TimeLeft = 60;
    gameState.q3CategoryActive = true;

    $('categorySelection').classList.add('hidden');
    startQ3CategoryTimer();
    showQ3CategoryQuestion();
}

function startQ3CategoryTimer() {
    $('timerDisplay').textContent = `Time left: ${gameState.q3TimeLeft}s`;
    gameState.q3Timer = setInterval(() => {
        gameState.q3TimeLeft--;
        $('timerDisplay').textContent = `Time left: ${gameState.q3TimeLeft}s`;
        if (gameState.q3TimeLeft <= 0) {
            finishQ3CategoryRound();
        }
    }, 1000);
}

function stopQ3CategoryTimer() {
    if (gameState.q3Timer) {
        clearInterval(gameState.q3Timer);
        gameState.q3Timer = null;
    }
}

function finishQ3CategoryRound() {
    const qArr = gameState.q3CategoryQuestions;
    stopQ3CategoryTimer();
    gameState.q3CategoryActive = false;
    $('answerInput').disabled = true;
    $('buzzerBtn').disabled = true;
    if ($('skipBtn')) $('skipBtn').remove();

    const correct = gameState.q3CategoryQuestions.filter(q => q.isCorrect).length;
    const points = correct * 10;

    let resultHtml = `<strong>Category complete!</strong><br>`;
    resultHtml += `You got <strong>${correct}/${qArr.length}</strong> correct (+${points} pts).<br><br>`;
    resultHtml += `<table style="width:100%;text-align:left;font-size:0.98em;background:#fff;"><thead><tr><th>#</th><th>Question</th><th>Your Answer</th><th>Correct Answer</th><th>‚úì</th></tr></thead><tbody>`;
    qArr.forEach((q, i) => {
        resultHtml += `<tr>
            <td>${i+1}</td>
            <td>${q.question}</td>
            <td>${q.userAnswer || "---"}</td>
            <td>${formatAnswer(q.answer)}</td>
            <td style="color:${q.isCorrect ? '#38a169':'#e53e3e'};">${q.isCorrect ? '‚úîÔ∏è':'‚ùå'}</td>
        </tr>`;
    });
    resultHtml += `</tbody></table>`;
    $('questionText').innerHTML = resultHtml;

    $('questionText').innerHTML = resultHtml;
    updateScoreDisplays();
    setFeedback(`Category complete! ${correct} correct, +${points} pts.`, true);
    setTimeout(() => {
        if (gameState.mode === 'full') {
            gameState.currentQuarter++;
            gameState.currentQuestionIndex = -1;
            gameState.q3selectedCategory = null;
            nextQuestion();
        } else {
            gameState.q3selectedCategory = null;
            showCategorySelection();
        }
    }, 4000);
}

function calculateAverageBuzzInTime() {
    if (!gameState.buzzInTimes.length) return null;
    const sum = gameState.buzzInTimes.reduce((a, b) => a + b, 0);
    return sum / gameState.buzzInTimes.length;
}

function showQ3CategoryQuestion() {
    const qArr = gameState.q3CategoryQuestions;
    const cat = QUESTIONS.q3[gameState.q3selectedCategory];
    const prefix = cat.prompt || "Millard Fillmore is or was...";
    $('q3PrefixBox').textContent = prefix;
    let idx = gameState.q3CurrentQuestionIdx;
    let cnt = 0;
    while (qArr[idx].userAnswer && cnt < qArr.length) {
        idx = (idx + 1) % qArr.length;
        cnt++;
    }

    if (cnt >= qArr.length) {
        finishQ3CategoryRound();
        return;
    }

    gameState.q3CurrentQuestionIdx = idx;
    const qObj = qArr[idx];

    // Record question start time for Q3
    gameState.questionStartTime = Date.now();

    $('questionText').textContent = `(${idx+1}/8) ${qObj.question}`;
    $('answerInput').disabled = false;
    $('answerInput').value = '';
    $('answerInput').focus();
    $('buzzerBtn').disabled = true;
    $('showAnswerBtn').disabled = true;

    if (!document.getElementById('skipBtn')) {
        const skipBtn = document.createElement('button');
        skipBtn.id = 'skipBtn';
        skipBtn.className = 'btn secondary';
        skipBtn.textContent = 'Skip';
        skipBtn.onclick = () => {
            const qArr = gameState.q3CategoryQuestions;
            let idx = gameState.q3CurrentQuestionIdx;
            if (!qArr[idx].userAnswer) {
                qArr[idx].userAnswer = "---";
                qArr[idx].isCorrect = false;
            }
            let nextIdx = (idx + 1) % qArr.length;
            let cnt = 0;
            while (qArr[nextIdx].userAnswer && cnt < qArr.length) {
                nextIdx = (nextIdx + 1) % qArr.length;
                cnt++;
            }
            if (!qArr.some(q => !q.userAnswer)) {
                finishQ3CategoryRound();
            } else {
                gameState.q3CurrentQuestionIdx = nextIdx;
                showQ3CategoryQuestion();
            }
        };
        $('answerInput').parentNode.insertBefore(skipBtn, $('answerInput').nextSibling);
    }
}

/* ------------------ Reading / typing effect ------------------ */
function startReading(){
    clearAllTimers();
    gameState.buzzed = false;
    gameState.multiplier = 1;
    updateScoreDisplays();
    clearFeedback();

    let questionText = "";
    let correctAnswer = "";
    gameState.currentBonus = null;

    if (gameState.currentQuarter === 1){
        const q = gameState.activeQ1[gameState.currentQuestionIndex];
        questionText = q ? q.question : "";
        correctAnswer = q ? q.answer : "";
    } else if (gameState.currentQuarter === 2){
        const q = gameState.activeQ2[gameState.currentQuestionIndex];
        questionText = q ? q.tossup.question : "";
        correctAnswer = q ? q.tossup.answer : "";
        gameState.currentBonus = q ? q.bonus : null;
    } else if (gameState.currentQuarter === 3){
        const cat = QUESTIONS.q3[gameState.q3selectedCategory];
        const qIndex = gameState.q3categoryProgress;
        const q = cat && cat.questions ? cat.questions[qIndex] : null;
        questionText = q ? q.question : "";
        correctAnswer = q ? q.answer : "";
    } else if (gameState.currentQuarter === 4){
        const q = gameState.activeQ4[gameState.currentQuestionIndex];
        if (!q){ questionText = ""; correctAnswer = ""; }
        else {
            gameState.currentQ4Parts = q.parts;
            questionText = q.parts.join(" ");
            correctAnswer = q.answer;
            // Calculate boundaries for buzz logic:
            let boundaries = [];
            let idx = 0;
            q.parts.forEach((part, i) => {
                boundaries.push({ part: i, start: idx, end: idx + part.length });
                idx += part.length + 1;
            });
            gameState.q4PartBoundaries = boundaries;
        }
    }

    if (!questionText) {
        $('questionText').textContent = "No question available.";
        return;
    }

    gameState.currentQuestionText = questionText;
    gameState.currentAnswer = correctAnswer;
    gameState.readingCharIndex = 0;
    $('questionText').textContent = "";
    $('timerDisplay').textContent = "--";

    gameState.readingInterval = setInterval(()=>{
        if (gameState.readingCharIndex < questionText.length && !gameState.buzzed){
            $('questionText').textContent += questionText[gameState.readingCharIndex];
            gameState.readingCharIndex++;
            if (gameState.currentQuarter === 4) {
                let idx = gameState.readingCharIndex;
                let boundaries = gameState.q4PartBoundaries;
                let partIndex = boundaries.length - 1;
                for (let i = 0; i < boundaries.length; i++) {
                    if (idx < boundaries[i].end) {
                        partIndex = i;
                        break;
                    }
                }
                gameState.q4CurrentPart = partIndex;
            }
        } else {
            clearInterval(gameState.readingInterval);
            gameState.readingInterval = null;
            if (!gameState.buzzed){
                let postReadTime = 5;
                $('timerDisplay').textContent = `Buzz time: ${postReadTime}`;
                gameState.postReadTimer = setInterval(()=>{
                    postReadTime--;
                    $('timerDisplay').textContent = `Buzz time: ${postReadTime}`;
                    if (postReadTime <= 0){
                        clearInterval(gameState.postReadTimer);
                        gameState.postReadTimer = null;
                        $('buzzerBtn').disabled = true;
                        $('timerDisplay').textContent = "Time's up";
                        setFeedback(`Time expired! No points awarded. The correct answer was: ${formatAnswer(gameState.currentAnswer)}`, false);
                        startFeedbackCountdown(10);
                        $('questionText').textContent = gameState.currentQuestionText;
                        setTimeout(()=> {
                            nextQuestion();
                        }, 10000); // 5 seconds to review
                    }
                }, 1000);
            }
        }
    }, 30);
}

/* ------------------ Buzz logic ------------------ */
function buzz(){
    if (gameState.buzzed) return;
    gameState.buzzed = true;
    gameState.buzzTime = Date.now(); // Record buzz time for response time calculation
    

    clearAllTimers();
    $('showAnswerBtn').disabled = true;
    // Calculate buzz-in time: from questionStartTime to buzzTime
    if (gameState.questionStartTime && gameState.buzzTime) {
        const buzzInTime = (gameState.buzzTime - gameState.questionStartTime) / 1000;
        gameState.buzzInTimes.push(buzzInTime);
    }
    let pctRead = 1;
    if (gameState.currentQuestionText && gameState.readingCharIndex){
        pctRead = gameState.readingCharIndex / gameState.currentQuestionText.length;
        if (pctRead < 0) pctRead = 0;
        if (pctRead > 1) pctRead = 1;
    }

    if (pctRead < 0.15) gameState.multiplier = 5;
    else if (pctRead < 0.35) gameState.multiplier = 4;
    else if (pctRead < 0.55) gameState.multiplier = 3;
    else if (pctRead < 0.8) gameState.multiplier = 2;
    else gameState.multiplier = 1;

    if (gameState.currentQuarter === 4) {
        let bracketPoints = 10;
        if (gameState.q4CurrentPart === 0) bracketPoints = 30;
        else if (gameState.q4CurrentPart === 1) bracketPoints = 20;
        else bracketPoints = 10;
        gameState.q4BracketPoints = bracketPoints;
    } else {
        gameState.q4BracketPoints = 10;
    }

    $('answerInput').disabled = false;
    $('showAnswerBtn').disabled = true;
    $('answerInput').focus();
    $('buzzerBtn').disabled = true;
    updateScoreDisplays();

    gameState.answerTimeLeft = 10;
    $('timerDisplay').textContent = `Answer time: ${gameState.answerTimeLeft}`;
    gameState.answerTimer = setInterval(()=>{
        gameState.answerTimeLeft--;
        $('timerDisplay').textContent = `Answer time: ${gameState.answerTimeLeft}`;
        if (gameState.answerTimeLeft <= 0){
            clearInterval(gameState.answerTimer);
            gameState.answerTimer = null;
            $('answerInput').disabled = true;
            $('timerDisplay').textContent = "Time expired";
            setFeedback("Time expired! No points awarded. The correct answer was: " + formatAnswer(gameState.currentAnswer), false);
            startFeedbackCountdown(10);
            $('questionText').textContent = gameState.currentQuestionText;
            setTimeout(()=> { 
                nextQuestion(); 
            }, 10000);
        }
    }, 1000);
}

/* ------------------ Show answer (for practice) ------------------ */
function showAnswer(){
    if (gameState.isShowingAnswer) return;
    gameState.isShowingAnswer = true;

    clearAllTimers();
    setFeedback(`Answer: ${formatAnswer(gameState.currentAnswer)}`, true);

    $('questionText').textContent = gameState.currentQuestionText || '---';
    $('buzzerBtn').disabled = true;
    $('answerInput').disabled = true;
    $('answerInput').value = '';
    $('showAnswerBtn').disabled = true;

    let secs = 10;
    $('timerDisplay').textContent = `Next question in: ${secs}`;
    gameState.feedbackTimeLeft = secs; // <--- Ensure this is set
    gameState.feedbackTimer = setInterval(() => {
        secs--;
        gameState.feedbackTimeLeft = secs; // <--- Update every tick
        $('timerDisplay').textContent = `Next question in: ${secs}`;
        if (secs <= 0) {
            clearInterval(gameState.feedbackTimer);
            gameState.feedbackTimer = null;
            $('timerDisplay').textContent = '--';
            gameState.isShowingAnswer = false;
            nextQuestion();
        }
    }, 1000);
}

/* ------------------ Answer checking & scoring ------------------ */
function normalize(s){
    return (s || "").toString().trim().toLowerCase();
}

function isStrictCorrect(given, answer) {
    const normGiven = normalize(given);
    if (Array.isArray(answer)) {
        return answer.some(a => normalize(a) === normGiven);
    } else {
        return normalize(answer) === normGiven;
    }
}

function normalizeAnswerArray(ans) {
    if (Array.isArray(ans)) return ans.map(a => a.trim().toLowerCase());
    return ans.split(',').map(a => a.trim().toLowerCase());
}
let givenNorm = given.trim().toLowerCase();
let answerArr = normalizeAnswerArray(qArr[idx].answer);
qArr[idx].isCorrect = answerArr.includes(givenNorm);

function submitAnswer(){
    if ($('answerInput').disabled) return;
    if(gameState.bonusTimer) {
        clearInterval(gameState.bonusTimer);
        gameState.bonusTimer = null;
    }

    const given = $('answerInput').value.trim();
    if (!given){
        setFeedback("Please type an answer before submitting.", false);
        return;
    }

    const submitTime = Date.now();

    // Calculate response time
    let responseTime = null;
    if (gameState.currentQuarter === 3 && gameState.q3CategoryActive) {
        // For Q3, use time since question was shown
        responseTime = (submitTime - gameState.questionStartTime) / 1000;
    } else if (gameState.buzzTime) {
        // For other quarters, use time from buzz to submit
        responseTime = (submitTime - gameState.buzzTime) / 1000;
    }

    // Update current response time display
    if (responseTime !== null) {
        $('currentResponseTime').textContent = `Response time: ${responseTime.toFixed(1)}s`;
    }

    // Quarter 3 timed category mode
    if (gameState.currentQuarter === 3 && gameState.q3CategoryActive) {
        const idx = gameState.q3CurrentQuestionIdx;
        const qArr = gameState.q3CategoryQuestions;
        qArr[idx].userAnswer = given;

        let msg;
        if (qArr[idx].isCorrect) {
            msg = `‚úîÔ∏è Correct! +10 pts`;
            gameState.rawScore += 10;
            if (responseTime !== null) {
                gameState.responseTimes.push(responseTime);
            }
            updateScoreDisplays();
        } else {
            let ans = Array.isArray(qArr[idx].answer) ? qArr[idx].answer.join(', ') : qArr[idx].answer;
            msg = `‚ùå Incorrect. Correct: ${formatAnswer(qArr[idx].answer)}`;
        }

        if (qArr.some(q => !q.userAnswer)) {
            let nextIdx = (idx + 1) % qArr.length;
            while (qArr[nextIdx].userAnswer) {
                nextIdx = (nextIdx + 1) % qArr.length;
            }
            gameState.q3CurrentQuestionIdx = nextIdx;
            showQ3CategoryQuestion();
        } else {
            finishQ3CategoryRound();
        }
        return;
    }

    // Clear answer timer immediately
    if (gameState.answerTimer){
        clearInterval(gameState.answerTimer);
        gameState.answerTimer = null;
    }

    $('answerInput').disabled = true;
    $('timerDisplay').textContent = "";

    const isCorrect = isStrictCorrect(given, gameState.currentAnswer) ||
                  looseMatch(given, gameState.currentAnswer);
    let basePoints = 0;
    let earnedPoints = 0;

    if (gameState.currentQuarter === 1){
        basePoints = 10;
        if (isCorrect){
            earnedPoints = basePoints;
            gameState.rawScore += earnedPoints;
            if (responseTime !== null) {
                gameState.responseTimes.push(responseTime);
            }
            updateScoreDisplays();
            setFeedback(`Correct! +${earnedPoints} points (${responseTime?.toFixed(1)}s)`, true);
            setTimeout(()=> {
                nextQuestion();
            }, 1500);
        } else {
            setFeedback(`Incorrect. The correct answer was: ${formatAnswer(gameState.currentAnswer)}`, false);
            startFeedbackCountdown(10);
            $('questionText').textContent = gameState.currentQuestionText;
            setTimeout(()=> {
                nextQuestion();
            }, 10000);
        }
    } else if (gameState.currentQuarter === 2){
        basePoints = 10;
        if (isCorrect){
            earnedPoints = basePoints;
            gameState.rawScore += earnedPoints;
            if (responseTime !== null) {
                gameState.responseTimes.push(responseTime);
            }
            updateScoreDisplays();
            setFeedback(`Correct tossup! +${earnedPoints} points. Now: bonus question.`, true);

            if (gameState.currentBonus){
                setTimeout(()=> {
                    $('questionText').textContent = gameState.currentBonus.question;
                    gameState.currentAnswer = gameState.currentBonus.answer;
                    gameState.multiplier = 1;
                    $('answerInput').disabled = false;
                    $('answerInput').value = '';
                    $('answerInput').focus();
                    gameState.isAnsweringBonus = true;
                    gameState.questionStartTime = Date.now(); // Reset for bonus timing
            
                    // === START BONUS TIMER ===
                    gameState.bonusTimeLeft = 20;
                    $('timerDisplay').textContent = `Bonus time: ${gameState.bonusTimeLeft}`;
                    gameState.bonusTimer = setInterval(() => {
                        gameState.bonusTimeLeft--;
                        $('timerDisplay').textContent = `Bonus time: ${gameState.bonusTimeLeft}`;
                        if (gameState.bonusTimeLeft <= 0) {
                            clearInterval(gameState.bonusTimer);
                            gameState.bonusTimer = null;
                            $('answerInput').disabled = true;
                            $('timerDisplay').textContent = "Bonus expired";
                            setFeedback(`Time expired! No points awarded. The correct answer was: ${formatAnswer(gameState.currentAnswer)}`, false);
                            startFeedbackCountdown(10);
                            $('questionText').textContent = gameState.currentBonus?.question || '';
                            // Mark we're not answering bonus anymore
                            gameState.currentBonus = null;
                            gameState.isAnsweringBonus = false;
                            setTimeout(()=> {
                                nextQuestion();
                            }, 10000);
                        }
                    }, 1000);
                    // === END BONUS TIMER ===
                }, 1000);
            } else {
                setTimeout(()=> {
                    nextQuestion();
                }, 1500);
            }
        } else {
            setFeedback(`Incorrect tossup. The correct answer was: ${formatAnswer(gameState.currentAnswer)}. (No bonus.)`, false);
            startFeedbackCountdown(10);
            $('questionText').textContent = gameState.currentBonus?.question || '';
            setTimeout(()=> {
                nextQuestion();
            }, 10000);
        }
    } else if (gameState.currentQuarter === 4){
        const bracketPoints = gameState.q4BracketPoints || 10;
        basePoints = bracketPoints;
        if (isCorrect){
            earnedPoints = basePoints;
            gameState.rawScore += earnedPoints;
            if (responseTime !== null) {
                gameState.responseTimes.push(responseTime);
            }
            updateScoreDisplays();
            setFeedback(`Correct! +${earnedPoints} points (${responseTime?.toFixed(1)}s)`, true);
            setTimeout(()=> nextQuestion(), 1500);
        } else {
            setFeedback(`Incorrect. The correct answer was: ${formatAnswer(gameState.currentAnswer)}`, false);
            startFeedbackCountdown(10);
            $('questionText').textContent = gameState.currentQuestionText;
            setTimeout(()=> nextQuestion(), 10000); // longer delay
        }
    }

    // Special: if we just answered a Q2 bonus 
    if (gameState.currentQuarter === 2 && gameState.isAnsweringBonus){
        const bonusIsCorrect = isCorrect;
        if (bonusIsCorrect){
            const bonusPoints = 10;
            gameState.rawScore += bonusPoints;
            // Calculate bonus response time from when bonus was shown
            const bonusResponseTime = (submitTime - gameState.questionStartTime) / 1000;
            gameState.responseTimes.push(bonusResponseTime);
            $('currentResponseTime').textContent = `Response time: ${bonusResponseTime.toFixed(1)}s`;
            updateScoreDisplays();
            setFeedback(`Correct bonus! +${bonusPoints} points (${bonusResponseTime.toFixed(1)}s)`, true);
        } else {
            setFeedback(`Incorrect bonus. The correct answer was: ${formatAnswer(gameState.currentAnswer)}`, false);
            startFeedbackCountdown(10);
            $('questionText').textContent = gameState.currentBonus?.question || '';
        }
        gameState.currentBonus = null;
        gameState.isAnsweringBonus = false;
        setTimeout(()=> {
            nextQuestion();
        }, bonusIsCorrect ? 1500 : 10000);
    }
}

function showQ3FeedbackPopup(msg, correct) {
    // Create modal if not exists
    let modal = document.getElementById('q3FeedbackModal');
    if (!modal) {
        modal = document.createElement('div');
        modal.id = 'q3FeedbackModal';
        modal.style.position = 'fixed';
        modal.style.top = '0';
        modal.style.left = '0';
        modal.style.width = '100vw';
        modal.style.height = '100vh';
        modal.style.background = 'rgba(0,0,0,0.3)';
        modal.style.zIndex = '99999';
        modal.style.display = 'flex';
        modal.style.alignItems = 'center';
        modal.style.justifyContent = 'center';
        modal.innerHTML = `<div style="background:#fff;padding:32px;border-radius:12px;max-width:420px;">
            <h3 style="color:${correct ? '#38a169':'#e53e3e'};">${correct ? 'Correct!' : 'Incorrect'}</h3>
            <div>${msg}</div>
            <div style="margin-top:18px;text-align:center">
                <button onclick="closeQ3FeedbackPopup()" class="btn">Continue</button>
            </div>
        </div>`;
        document.body.appendChild(modal);
    } else {
        modal.querySelector('h3').textContent = correct ? 'Correct!' : 'Incorrect';
        modal.querySelector('h3').style.color = correct ? '#38a169':'#e53e3e';
        modal.querySelector('div > div').textContent = msg;
        modal.style.display = 'flex';
    }
}
function closeQ3FeedbackPopup() {
    let modal = document.getElementById('q3FeedbackModal');
    if (modal) modal.style.display = 'none';
    // After closing, go to next question or finish
    const qArr = gameState.q3CategoryQuestions;
    const idx = gameState.q3CurrentQuestionIdx;
    if (qArr.some(q => !q.userAnswer)) {
        let nextIdx = (idx + 1) % qArr.length;
        while (qArr[nextIdx].userAnswer) {
            nextIdx = (nextIdx + 1) % qArr.length;
        }
        gameState.q3CurrentQuestionIdx = nextIdx;
        showQ3CategoryQuestion();
    } else {
        finishQ3CategoryRound();
    }
}

/* ------------------ Utility functions ------------------ */
function computeQuestionCounterText(){
    const q = gameState.currentQuarter;
    if (q === 1) return `Q ${Math.max(0, gameState.currentQuestionIndex+1)} / ${gameState.activeQ1.length}`;
    if (q === 2) return `Q ${Math.max(0, gameState.currentQuestionIndex+1)} / ${gameState.activeQ2.length}`;
    if (q === 3){
        if (gameState.q3selectedCategory !== null){
            const cat = QUESTIONS.q3[gameState.q3selectedCategory];
            return `Category ${cat.category} ‚Äî Q ${gameState.q3categoryProgress+1} / ${cat.questions.length}`;
        }
        return `Select category`;
    }
    if (q === 4) return `Q ${Math.max(0, gameState.currentQuestionIndex+1)} / ${gameState.activeQ4.length}`;
    return '';
}

function startFeedbackCountdown(seconds) {
    $('timerDisplay').textContent = `Next question in: ${seconds}`;
    let timeLeft = seconds;
    gameState.feedbackTimeLeft = timeLeft; // <--- Track time left in gameState
    if (gameState.feedbackTimer) clearInterval(gameState.feedbackTimer);
    gameState.feedbackTimer = setInterval(() => {
        timeLeft--;
        gameState.feedbackTimeLeft = timeLeft; // <--- Update on every tick!
        $('timerDisplay').textContent = `Next question in: ${timeLeft}`;
        if (timeLeft <= 0) {
            clearInterval(gameState.feedbackTimer);
            gameState.feedbackTimer = null;
            $('timerDisplay').textContent = '--';
        }
    }, 1000);
}

function formatAnswer(ans) {
    if (Array.isArray(ans)) return ans.join(', ');
    if (typeof ans === 'string' && ans.includes(',')) return ans.split(',').map(s => s.trim()).join(', ');
    return ans;
}
/* ------------------ Finish/End-game ------------------ */
async function finishGame() {
    clearAllTimers();

    const totalScore = gameState.rawScore;
    const avgBuzz = calculateAverageBuzzInTime();

    // Get player name from input
    const playerName = $('playerNameInput').value.trim() || "Anonymous";

    // Build the score entry
    const entry = {
      date: new Date().toISOString(),
      name: $('playerNameInput').value.trim() || "Anonymous",
      totalScore: totalScore,
      averageBuzzInTime: avgBuzz
    };
    await saveScoreToGlobalLeaderboard(entry);


    // Update UI
    $('questionText').textContent = `Game finished! Score: ${totalScore} / Avg Buzz-in: ${avgBuzz ? avgBuzz.toFixed(1) + 's' : 'N/A'} . Saved to global leaderboard.`;
    setFeedback("Game complete ‚Äî check the leaderboard from the menu.", true);
    $('buzzerBtn').disabled = true;
    $('answerInput').disabled = true;
}

/* ------------------ Save score to global leaderboard ------------------ */
async function saveScoreToGlobalLeaderboard(entry) {
    const WORKER_URL = "https://patient-base-c952.javalutionization.workers.dev";

    try {
        const res = await fetch(WORKER_URL, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(entry),
        });

        if (!res.ok) throw new Error(`Failed to save score: ${res.status} ${res.statusText}`);

        console.log("Score saved globally!");
    } catch (err) {
        console.error("Error saving score:", err);
        alert("Failed to save score to global leaderboard.");
    }
}

/* ------------------ Render global leaderboard ------------------ */
async function renderGlobalLeaderboard() {
    const WORKER_URL = "https://patient-base-c952.javalutionization.workers.dev";
    const container = $('leaderboardList');
    container.innerHTML = 'Loading...';

    try {
        const res = await fetch(WORKER_URL, { method: "GET" });
        if (!res.ok) throw new Error(`Failed to fetch leaderboard: ${res.status} ${res.statusText}`);
        const scores = await res.json();


        container.innerHTML = '';
        if (!scores.length) {
            container.textContent = 'No scores yet.';
            return;
        }

        // Sort scores by totalScore descending and take top 10
        const topScores = scores
          .sort((a, b) => b.totalScore - a.totalScore)
          .slice(0, 10);
        
        container.innerHTML = `
          <table style="width:100%;background:#fff;border-radius:8px;overflow:hidden;">
            <thead style="background:#f3f4f6;">
              <tr>
                <th style="padding:8px;text-align:center;">#</th>
                <th style="padding:8px;">Name</th>
                <th style="padding:8px;">Date</th>
                <th style="padding:8px;">Score</th>
                <th style="padding:8px;">Avg Buzz-in</th>
              </tr>
            </thead>
            <tbody>
              ${topScores.map((e, idx) => {
                // Define the style string once for both rank and name
                let style = '';
                if (idx === 0) style = 'color:#8646C7;font-weight:bold;font-size:1.5em;';
                else if (idx === 1) style = 'color:#7146C7;font-weight:bold;font-size:1.4em;';
                else if (idx === 2) style = 'color:#4E59BC;font-weight:bold;font-size:1.3em;';
                else if (idx === 3 || idx === 4) style = 'color:#457CB7;font-weight:600;font-size:1.2em;';
                else if (idx >= 5 && idx < 10) style = 'color:#2F547C;font-weight:600;font-size:1.1em;';
                
                return `
                  <tr style="border-bottom:1px solid #eef2f7;">
                    <td style="padding:8px;text-align:center;">
                      <span style="${style}">${idx + 1}</span>
                    </td>
                    <td style="padding:8px;${style}">${e.name || "Anonymous"}</td>
                    <td style="padding:8px;">${new Date(e.date).toLocaleString()}</td>
                    <td style="padding:8px;font-weight:700;">${e.totalScore}</td>
                    <td style="padding:8px;">${e.averageBuzzInTime ? e.averageBuzzInTime.toFixed(1) + 's' : 'N/A'}</td>
                  </tr>
                `;
              }).join('')}
            </tbody>
          </table>
          <div class="small muted" style="margin-top:8px;">Showing top 10 scores by total points.</div>
        `;
    } catch (err) {
        console.error(err);
        container.textContent = 'Failed to load leaderboard.';
    }
}




/* ------------------ Import/Export Questions ------------------ */


/* Render a simple questions display */
function renderQuestionsDisplay(){
    const container = $('questionsDisplay');
    container.innerHTML = '';

    const summary = document.createElement('div');
    summary.innerHTML = `
        <h4>Loaded Questions Summary:</h4>
        <p>Quarter 1: ${QUESTIONS.q1.length} questions</p>
        <p>Quarter 2: ${QUESTIONS.q2.length} questions</p>
        <p>Quarter 3: ${QUESTIONS.q3.length} categories</p>
        <p>Quarter 4: ${QUESTIONS.q4.length} questions</p>
    `;
    container.appendChild(summary);
}

function promptPracticeSet() {
    // List of available filenames and display names
    const availableFiles = [
      {
        year: "2014-2015",
        sets: [
          { name: "2014-2015 Round 1", file: "historybowlquestionsets/2014-2015/2014-2015HistoryBowlRound1.json" },
          { name: "2014-2015 Round 2", file: "historybowlquestionsets/2014-2015/2014-2015HistoryBowlRound2.json" },
          { name: "2014-2015 Round 3", file: "historybowlquestionsets/2014-2015/2014-2015HistoryBowlRound3.json" },
          { name: "2014-2015 Round 4", file: "historybowlquestionsets/2014-2015/2014-2015HistoryBowlRound4.json" },
          { name: "2014-2015 Round 5", file: "historybowlquestionsets/2014-2015/2014-2015HistoryBowlRound5.json" },
          { name: "2014-2015 Round 6", file: "historybowlquestionsets/2014-2015/2014-2015HistoryBowlRound6.json" },
          { name: "2014-2015 Round 7", file: "historybowlquestionsets/2014-2015/2014-2015HistoryBowlRound7.json" },
          { name: "2014-2015 Round 8", file: "historybowlquestionsets/2014-2015/2014-2015HistoryBowlRound8.json" },
          { name: "2014-2015 Round 9", file: "historybowlquestionsets/2014-2015/2014-2015HistoryBowlRound9.json" },
          { name: "2014-2015 Extras", file: "historybowlquestionsets/2014-2015/2014-2015HistoryBowlExtras.json" },
          // ...more 2014-2015 sets
        ]
      }
      // Add more years as needed
    ];

    // Return a promise that resolves with the selected files
    return new Promise(resolve => {
        openSetPicker(availableFiles, files => resolve(files));
    });
}

/* ------------------ Key handling ------------------ */
document.addEventListener('keydown', function(e){
    if (e.key === 'Enter'){
        if (!$('answerInput').disabled && document.activeElement === $('answerInput')){
            submitAnswer();
        }
    }
});

/* ------------------ Page init ------------------ */
function init(){
    resetGame();
    updateScoreDisplays();
    updateQuestionsStatus('Loading questions from server...', true);

    // Automatically load questions when the page loads
    loadQuestionsFromServer();
}

init();

</script>
</body>
</html>
